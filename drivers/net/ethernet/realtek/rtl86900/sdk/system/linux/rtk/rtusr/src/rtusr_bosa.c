/*
 * Include Files
 */
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <osal/lib.h>
#include <rtk/rtusr/include/rtusr_util.h>
#include <rtdrv/rtdrv_netfilter.h>
#include <common/rt_type.h>

#define HIGH   1
#define LOW    0
#define DELAY_TIME  300
#define TRANSCEIVER_A0 0x50
#define TRANSCEIVER_A2 0x51
#define BOSA_BUFF  1024
#define BOSA_BIN_PATH "/var/config/bosa_calibrate.bin"

#define A0_LOW   0
#define A0_HIG   128
#define A2_LOW   256
#define TABLE0   384
#define TABLE3   512
#define TABLE4   640
#define TABLE5   768
#define TABLE6   896

#define CHKSUM_OA   0xDB
#define CHKSUM_EA   (TABLE3+0xDB-128)

#define BOSA_WRITE_DELAY   100

const uint8 a0_low[128]=
{
    0x02,0xa0,0x80,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x03,0x0c,0x00,0x14,0xc8,
    0x00,0x00,0x00,0x00,0x63,0x6f,0x6d,0x6e,0x65,0x63,0x74,0x20,0x20,0x20,0x20,0x20,
    0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x55,0x58,0x33,0x33,0x32,0x30,0x20,0x20,
    0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x30,0x30,0x30,0x20,0x05,0x1e,0x00,0x0f,
    0x00,0x1c,0x00,0x00,0x52,0x45,0x31,0x39,0x30,0x31,0x30,0x33,0x31,0x30,0x30,0x30,
    0x30,0x30,0x30,0x34,0x31,0x39,0x30,0x31,0x30,0x33,0x00,0x00,0x68,0xb0,0x03,0xbd,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
};

const uint8 a2_low[128]=
{
    0x50,0x00,0xf3,0x00,0x4b,0x00,0xf8,0x00,0x8c,0xa0,0x75,0x30,0x88,0xb8,0x79,0x18,
    0x7e,0xf4,0x00,0x00,0x6b,0x6c,0x00,0x00,0x9b,0x82,0x22,0xd0,0x8a,0x99,0x27,0x10,
    0x07,0xcb,0x00,0x0a,0x06,0x30,0x00,0x0c,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x3f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
    0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0xff,0xff,0xff,0xa8,
    0x1e,0x80,0x83,0xe8,0x15,0x84,0x43,0x8c,0x00,0x08,0xff,0xff,0xff,0xff,0x22,0x00,
    0x00,0x40,0x00,0xff,0x00,0x40,0xff,0xff,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,
};

const uint8 table0[128]=
{
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0xff,0xff,0xff,0xc0,0xff,0xff,
};

const uint8 table3[128]=
{
    0xaa,0x00,0xc9,0xe8,0xe3,0x1a,0x00,0x2f,0x02,0xc0,0x04,0x00,0x0b,0x02,0x40,0x88,
    0xdc,0xc8,0x00,0x00,0x09,0x00,0x00,0x00,0x00,0x34,0x00,0x00,0x02,0x4b,0x68,0x10,
    0x00,0x00,0x88,0x00,0x00,0x00,0xa3,0xa3,0x01,0xe5,0x86,0x77,0x01,0xe5,0x86,0x77,
    0x01,0xe5,0x86,0x77,0x01,0x00,0xf8,0xe8,0x00,0xcc,0x00,0x00,0x05,0x36,0xff,0xce,
    0x00,0x52,0xff,0xfe,0x00,0x52,0xff,0xfe,0x00,0x52,0xff,0xfe,0x13,0x20,0x00,0x22,
    0xa2,0x40,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,0x55,0x00,0x0c,0x87,
    0x00,0x00,0x00,0x00,0x05,0x05,0x02,0xaf,0x42,0xc0,0x4e,0x00,0x08,0x60,0x05,0x1c,
    0x00,0x00,0x1e,0xb0,0xd4,0x80,0xd6,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
};

const uint8 table4[128]=
{
    0x15,0x45,0x51,0x54,0x55,0x15,0x45,0x51,0x54,0x55,0x15,0x45,0x51,0x54,0x55,0x15,
    0x85,0x61,0x58,0x56,0x15,0x85,0x61,0x58,0x56,0x15,0xc5,0x71,0x5c,0x57,0x15,0xc5,
    0x71,0x60,0x58,0x16,0x05,0x81,0x60,0x58,0x16,0x05,0x81,0x64,0x59,0x16,0x45,0xa1,
    0x6c,0x5b,0x17,0x45,0xe1,0x78,0x5e,0x18,0x46,0x11,0x8c,0x63,0x19,0x06,0x61,0x98,
    0x66,0x1a,0x46,0xa1,0xb0,0x6c,0x1c,0x07,0x31,0xd8,0x76,0x1e,0xc7,0xd2,0x00,0x80,
    0x21,0x88,0x92,0x3c,0x8f,0x26,0x09,0xc2,0x84,0xa1,0x2a,0xca,0xf2,0xd0,0xb4,0x2d,
    0x0b,0x42,0xd0,0xb4,0x2d,0x0b,0x42,0xd0,0xb4,0x40,0x65,0xc0,0x68,0x00,0x6a,0xc0,
    0x6d,0x80,0x70,0x80,0x73,0x80,0x76,0xc0,0x7a,0x40,0x7e,0x00,0x81,0xc0,0x86,0x40,
};

const uint8 table5[128]=
{
    0x28,0x4a,0x12,0x84,0xa1,0x28,0x4a,0x12,0x84,0xa1,0x28,0x4a,0x12,0x88,0xa2,0x28,
    0xca,0x32,0x90,0xa4,0x29,0x0a,0x52,0x94,0xa5,0x29,0x4a,0x52,0x94,0xa5,0x29,0x8a,
    0x62,0x9c,0xa7,0x29,0xca,0x72,0xa0,0xa8,0x2a,0x0a,0x82,0xa4,0xa9,0x2a,0x8a,0xc2,
    0xb4,0xad,0x2c,0x4b,0x22,0xd0,0xb4,0x2e,0x0b,0x92,0xf0,0xbc,0x2f,0xcc,0x23,0x0c,
    0xc3,0x32,0x0c,0xa3,0x38,0xce,0x35,0x4d,0xa3,0x80,0xe0,0x3a,0x8e,0xe3,0xcc,0xf3,
    0x3f,0xd0,0x64,0x3d,0x0f,0x48,0x52,0xa4,0xcd,0x33,0x51,0x54,0xe5,0x5d,0x57,0x55,
    0xd5,0x75,0x5d,0x57,0x55,0xd5,0x75,0x5d,0x57,0x00,0xbe,0x80,0xc9,0xc0,0xd5,0xc0,
    0xe2,0xc0,0xf0,0xc0,0xff,0xc0,0xff,0xc0,0xff,0xc0,0xff,0xc0,0xff,0xc0,0xff,0xc0,
};

const uint8 table6[128]=
{
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0x42,0x42,0x42,0x42,0x43,0x46,0x48,0x4b,0x4d,0x50,0x53,0x55,0x58,0x5a,0x5d,0x5f,
    0x62,0x64,0x67,0x69,0x6c,0x6e,0x71,0x73,0x75,0x77,0x79,0x7b,0x7d,0x7f,0x81,0x83,
    0x85,0x87,0x89,0x8b,0x8d,0x8f,0x91,0x93,0x95,0x97,0x99,0x9b,0x9d,0x9e,0x9e,0x9e,
    0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,
};

int write_pwd2(void)
{
    int ret = -1;
    int idx;
    uint32 int_temp = 0;

    //printf("write pwd2 \n");
    for(idx = 0x7b; idx <= 0x7e; idx++)
    {
        int_temp  = 0xffffffff;
        ret = rtk_i2c_write(I2C_PORT_0, TRANSCEIVER_A2, idx, int_temp);
        usleep(BOSA_WRITE_DELAY);
    }

    return ret;
}

int select_table(uint8 num)
{
    int ret = -1;

    //printf("select table %d \n", num);
    ret = rtk_i2c_write(I2C_PORT_0, TRANSCEIVER_A2, 0x7f, num);
    usleep(BOSA_WRITE_DELAY);

    return ret;
}

int read_date(uint32 devID, uint32 addr_oa, uint32 start, uint32 end, uint8 *buf)
{
    int ret = -1;
    uint32 idx = 0;
    uint32 i = 0;
    uint32 temp = 0;
    uint32 addr_ea = start%128+addr_oa;

    for(i = 0; i <= (end-start); i++)
    {
        temp  = 0xffffffff;
        ret = rtk_i2c_read(I2C_PORT_0, devID, start+i, &temp);
        buf[addr_ea+i] = (uint8)temp;
    }
    
    return ret;
}

int write_date(uint32 devID, uint32 addr_oa, uint32 start, uint32 end, uint8 *buf)
{
    int ret = -1;
    uint32 i = 0;
    uint32 temp = 0;
    uint32 addr_ea = start%128+addr_oa;

    for(i = 0; i <= (end-start); i++)
    {
        temp  = buf[addr_ea+i];
        ret = rtk_i2c_write(I2C_PORT_0, devID, start+i, temp);
        usleep(BOSA_WRITE_DELAY);
    }
    
    return ret;
}

unsigned int chksum(unsigned char *buf, unsigned int start, unsigned int end)
{
    unsigned i = 0;
    unsigned int chksum = 0;

    for(i=0; i <= (end -start); i++)
    {
        chksum += buf[i];
    }

    return chksum;
}

int chksum_read_data(unsigned char *buf)
{
    unsigned int chksum_data = 0;
    /* 表4(80h-E8h)，表5(80h-E8h)，表6(80h-E8h)和表3(82h-D2h)字节之和的低8位 */
    chksum_data = chksum(&buf[TABLE4], 0x80, 0xe8);
    chksum_data += chksum(&buf[TABLE5], 0x80, 0xe8);
    chksum_data += chksum(&buf[TABLE6], 0x80, 0xe8);
    chksum_data += chksum(&buf[TABLE3+2], 0x82, 0xd2);
    chksum_data =  chksum_data & 0xff;

    if(buf[CHKSUM_EA] != chksum_data)
    {
        printf("buf[CHKSUM_EA]=%x , chksum_data =%x \n", buf[CHKSUM_EA], chksum_data);
        return -1;
    }
    
    return 0; 
}

int rtusr_bosa_calibrate_export(uint8 *read_buf, uint8 show)
{
    int ret = -1;
    int i = 0;
    int j = 0;

    uint8 rcv_data[256] = {0};
    rtk_i2c_init(I2C_PORT_0);
    rtk_i2c_enable_set(I2C_PORT_0, ENABLED);

    write_pwd2( );

    memset(read_buf, 0xff, BOSA_BUFF);
    ret = read_date(TRANSCEIVER_A0, A0_LOW, 0, 127, read_buf);
    ret = read_date(TRANSCEIVER_A0, A0_HIG, 128, 255, read_buf);
    ret = read_date(TRANSCEIVER_A2, A2_LOW, 0, 127, read_buf);

    select_table(0);
    ret = read_date(TRANSCEIVER_A2, TABLE0, 128, 255, read_buf);

    select_table(3);
    ret = read_date(TRANSCEIVER_A2, TABLE3, 128, 255, read_buf);

    select_table(4);
    ret = read_date(TRANSCEIVER_A2, TABLE4, 128, 255, read_buf);

    select_table(5);
    ret = read_date(TRANSCEIVER_A2, TABLE5, 128, 255, read_buf);
    
    select_table(6);
    ret = read_date(TRANSCEIVER_A2, TABLE6, 128, 255, read_buf);

    if(show == 1)
    {
        for ( i = 0 ; i < 8 ; i++ )
        {        
            if(i == 0)
                printf("read A0 0~127 \n");
            else if(i == 1)
                printf("read A0 128~255 \n");
            else if(i == 2)
                printf("read A2 0~127 \n");
            else if(i == 3)
                printf("read A2 table0 \n");
            else if(i == 4)
                printf("read A2 table3 \n");
            else if(i == 5)
                printf("read A2 table4 \n");
            else if(i == 6)
                printf("read A2 table5 \n");
            else if(i == 7)
                printf("read A2 table6 \n");

            for ( j = 0 ; j < 128 ; j++ )
            {
                printf("%02x ", read_buf[(i*128)+j]);
                if(((j+1)%16) == 0)
                    printf("\n");     
            }  
        }
    }

    return ret;
}

int rtusr_bosa_calibrate_default_import(void)
{
    int ret = -1;
    int idx = 0;
    uint32 int_temp = 0;
    
    rtk_i2c_init(I2C_PORT_0);
    rtk_i2c_enable_set(I2C_PORT_0, ENABLED);

    printf("rtusr_bosa_calibrate_default_import \n");
    for(idx = 0; idx < 128; idx++)
    {
        int_temp  = a0_low[idx];
        ret = rtk_i2c_write(I2C_PORT_0, TRANSCEIVER_A0, idx, int_temp);
        usleep(BOSA_WRITE_DELAY);
    }

    for(idx = 0; idx < 128; idx++)
    {
        int_temp  = a2_low[idx];
        ret = rtk_i2c_write(I2C_PORT_0, TRANSCEIVER_A2, idx, int_temp);
        usleep(BOSA_WRITE_DELAY);
    }

    write_pwd2( );

    select_table(0);
    ret = rtk_i2c_write(I2C_PORT_0, TRANSCEIVER_A2, 0x7f, 0x0);
    usleep(BOSA_WRITE_DELAY);
    for(idx = 128; idx < 256; idx++)
    {
        int_temp  = table0[idx-128];
        ret = rtk_i2c_write(I2C_PORT_0, TRANSCEIVER_A2, idx, int_temp);
        usleep(BOSA_WRITE_DELAY);
    }

    select_table(3);
    ret = rtk_i2c_write(I2C_PORT_0, TRANSCEIVER_A2, 0x7f, 0x3);
    usleep(BOSA_WRITE_DELAY);
    for(idx = 128; idx <= 220; idx++)
    {
        int_temp  = table3[idx-128];
        ret = rtk_i2c_write(I2C_PORT_0, TRANSCEIVER_A2, idx, int_temp);
        usleep(BOSA_WRITE_DELAY);
    }

    select_table(4);
    ret = rtk_i2c_write(I2C_PORT_0, TRANSCEIVER_A2, 0x7f, 0x4);
    usleep(BOSA_WRITE_DELAY);
    for(idx = 128; idx <= 232; idx++)
    {
        int_temp  = table4[idx-128];
        ret = rtk_i2c_write(I2C_PORT_0, TRANSCEIVER_A2, idx, int_temp);
        usleep(BOSA_WRITE_DELAY);
    }

    select_table(5);
    ret = rtk_i2c_write(I2C_PORT_0, TRANSCEIVER_A2, 0x7f, 0x5);
    usleep(BOSA_WRITE_DELAY);
    for(idx = 128; idx <= 232; idx++)
    {
        int_temp  = table5[idx-128];
        ret = rtk_i2c_write(I2C_PORT_0, TRANSCEIVER_A2, idx, int_temp);
        usleep(BOSA_WRITE_DELAY);
    }

    select_table(6);
    ret = rtk_i2c_write(I2C_PORT_0, TRANSCEIVER_A2, 0x7f, 0x6);
    usleep(BOSA_WRITE_DELAY);
    for(idx = 128; idx <= 232; idx++)
    {
        int_temp  = table6[idx-128];
        ret = rtk_i2c_write(I2C_PORT_0, TRANSCEIVER_A2, idx, int_temp);
        usleep(BOSA_WRITE_DELAY);
    }

    return ret;
}


int  rtusr_bosa_calibrate_import(unsigned char *buf)
{
    int ret = -1;
    
    rtk_i2c_init(I2C_PORT_0);
    rtk_i2c_enable_set(I2C_PORT_0, ENABLED);

    printf("rtusr_bosa_calibrate_import \n");
    
    ret = write_date(TRANSCEIVER_A0, A0_LOW, 0, 127, buf);
    ret = write_date(TRANSCEIVER_A2, A2_LOW, 0, 127, buf);
    
    write_pwd2( );
    
    select_table(0);
    ret = write_date(TRANSCEIVER_A2, TABLE0, 128, 255, buf);
    
    select_table(3);
    ret = write_date(TRANSCEIVER_A2, TABLE3, 128, 220, buf);
    
    select_table(4);
    ret = write_date(TRANSCEIVER_A2, TABLE4, 128, 232, buf);
    
    select_table(5);
    ret = write_date(TRANSCEIVER_A2, TABLE5, 128, 232, buf);
    
    select_table(6);
    ret = write_date(TRANSCEIVER_A2, TABLE6, 128, 232, buf);

    return ret;

}

int check_calibrate_from_EEPROM(void)
{
    uint32 A2_80 = 0;
    uint32 A2_DC = 0;
    uint32 A2_F0 = 0;
 
    rtk_i2c_init(I2C_PORT_0);
    rtk_i2c_enable_set(I2C_PORT_0, ENABLED);

    select_table(2);
    /*
      通过读取 table2 0x80, table2 0xDC, 判断是 UX3320 还是 GN25L95 芯片,
    */    
    rtk_i2c_read(I2C_PORT_0, TRANSCEIVER_A2, 0x80, &A2_80);
    rtk_i2c_read(I2C_PORT_0, TRANSCEIVER_A2, 0xDC, &A2_DC); 
    /*
      如果数据通讯失败，则寄存器 INIT_STATE (table 3,F0h)的相应位将被置 1，
      当EEPROM不能响应设备地址A0时bit4置为1,
      当EEPROM不能响应设备地址A2时bit5置为1,
    */   
    rtk_i2c_read(I2C_PORT_0, TRANSCEIVER_A2, 0xF0, &A2_F0);
    select_table(0);
    
    //printf("check_calibrate_from_EEPROM A2_80=%x A2_DC=%x A2_F0=%x \n", A2_80, A2_DC, A2_F0);

    //A2_80=aa A2_DC=55 A2_F0=1
    if(A2_80 == 0xAA && A2_DC == 0x55 && (!(A2_F0 & 0x30)))
    {
        /* 
          UX3320 芯片, 需要从 EEPROM 芯片导入校准参数
          检测到A0 bit4和A2 bit5都为 0，是老的板子有EEPROM芯片，
        */
        return 1;
    }
    //A2_80=0 A2_DC=0 A2_F0=ff
    else if(A2_80 == 0 && A2_DC == 0 && (A2_F0 & 0x30))  // UX3320 芯片,从 FLASH 导入校准参数   
    {
        /* 
          UX3320 芯片, 需要从 FLASH 芯片导入校准参数
          检测到A0 bit4和A2 bit5都为 1，新的板子没有EEPROM芯片，
        */ 
        return 0;
    }

    /* 
        如果是 GN25L95 芯片，需要从 EEPROM 芯片导入校准参数
    */     

    return 1; 
}

int rtusr_bosa_calibrate_load(void)
{
    FILE *fp;
    uint8 read_buf[BOSA_BUFF] = {0};
    unsigned int chksum_data = 0;
    char import_default = 0;
    
    /* 
      如果检测到A0 bit4和A2 bit5都为非1，则是老的板子有EEPROM芯片，
      已经从EEPROM芯片导入校准参数，直接退出
    */
    if(check_calibrate_from_EEPROM()) 
    {
        printf("load bosa calibrate from EEPROM \n");
        return 0;
    }
    
    printf("load bosa calibrate from FLASH \n");

    if((fp = fopen(BOSA_BIN_PATH, "rb")) == NULL)
    {
        printf("Open file "BOSA_BIN_PATH" failed !!!\n");
        import_default = 1;
    }
    else
    {
        //fwrite(buf, sizeof(char), c, fp2);
        if(fread(read_buf, sizeof(char), BOSA_BUFF, fp) != BOSA_BUFF)
        {
            printf("Read file "BOSA_BIN_PATH" failed !!!\n");
            import_default = 1;
        }
        fclose(fp);
    }
    
    if(import_default == 0 && chksum_read_data(read_buf))
        import_default = 1;
        
	while(1)
	{
	    if(import_default == 1)
            rtusr_bosa_calibrate_default_import( );
	    else
	        rtusr_bosa_calibrate_import(read_buf);

		rtusr_bosa_calibrate_export(read_buf, 0);
		if(chksum_read_data(read_buf))
		{
		    printf("import bosa calibrate failed !!!\n");
		    sleep(2);
		    
		}
		else
		{
		    printf("import bosa calibrate success \n");
		    break;
		}
	}

    return 0;
}

void rtusr_bosa_calibrate_show(void)
{
    uint8 read_buf[BOSA_BUFF] = {0};
    
    rtusr_bosa_calibrate_export(read_buf, 1);
}

int rtusr_bosa_calibrate_save(void)
{
    FILE *fp;
    uint8 read_buf[BOSA_BUFF] = {0};

    /* 
      如果检测到A0 bit4和A2 bit5都为非1，则是老的板子有EEPROM芯片，
      已经从EEPROM芯片导入校准参数，不要保存到 flash
    */
    if(check_calibrate_from_EEPROM())
        return 0;

	rtusr_bosa_calibrate_export(read_buf, 0);
	if(chksum_read_data(read_buf))
	    return -1;

    if((fp = fopen(BOSA_BIN_PATH, "wb")) == NULL)
    {
        printf("Open file "BOSA_BIN_PATH" failed !!!\n");
        return -1;
    }

    if(fwrite(read_buf, sizeof(char), BOSA_BUFF, fp) != BOSA_BUFF)
    {
        printf("write file "BOSA_BIN_PATH" failed !!!\n");
        fclose(fp);
        return -1;
    }
    
    fclose(fp);
    
    return 0;   
}

